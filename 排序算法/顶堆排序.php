<?php
/**
 *
 * 一、堆的定义
    堆通常是一个可以被看做一棵树的数组对象，其任一非叶节点满足以下性质：
    1）堆中某个节点的值总是不大于或不小于其父节点的值：
    　　每个节点的值都大于或等于其左右子节点的值，称为大顶堆。即：arr[i] >= arr[2i + 1] && arr[i] >= arr[2i+2]。
 *     即堆顶元素为最大值
    　　或：
    　　每个节点的值都小于或等于其左右子节点的值，称为小顶堆。即：arr[i] <= arr[2i + 1] && arr[i] <= arr[2i+2]。
 *     即堆顶元素为最小值
    2）堆总是一棵完全二叉树。
 *
 * 注：上述公式，根节点从0开始。如果根节点从1开始，则左右子节点分别是2i和2i+1。
 *
 * 由上述性质可知：堆顶元素（或完全二叉树的根）必定是所有元素中最大值（大顶堆）或最小值（小顶堆）。
 *
 * 堆排序是基于完全二叉树实现的，在将一个数组调整成一个堆的时候，关键之一的是确定最后一个非叶子节点的序号，这个序号为n/2-1，n为数组的长度。但是为什么呢？

    可以分两种情形考虑：（基于下标为0开始）

        ①堆的最后一个非叶子节点若只有左孩子

        ②堆的最后一个非叶子节点有左右两个孩子

        完全二叉树的性质之一是：如果节点序号为i，在它的左孩子序号为2*i+1，右孩子序号为2*i+2。

    对于①左孩子的序号为n-1，则n-1=2*i+1，推出i=n/2-1；

    对于②左孩子的序号为n-2，在n-2=2*i+1，推出i=(n-1)/2-1；右孩子的序号为n-1，则n-1=2*i+2，推出i=(n-1)/2-1；

    很显然，当完全二叉树最后一个节点是其父节点的左孩子时，树的节点数为偶数；当完全二叉树最后一个节点是其父节点的右孩子时，树的节点数为奇数。

    根据java语法的特征，整数除不尽时向下取整，则若n为奇数时(n-1)/2-1=n/2-1。

    因此对于②最后一个非叶子节点的序号也是n/2-1。
 *
 * 二、基本思想
    以大顶堆为例，将待排序的序列构造成一个大根堆，此时，整个序列的最大值就是堆顶的根节点。
 *  将它移走（也就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小的值。
 *  如此反复执行，便能得到一个有序序列了。
 *
 * 三、算法过程
    1）将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
    2）将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
    3）重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
    以大顶堆为例
 *
 * 创建堆：
    1）将n个元素从0到n-1（或从1到n）自顶向下、从左到右编码，转换成一棵完全二叉树；
    2）从 n/2 - 1 的非叶节点开始到根节点，逐个扫描，如果子节点大于父节点，就交换；
    3）直到根节点最大，如果子树不满足最大堆的条件，继续调节，直到所有的父节点都大于子节点为止。
 *
 * 堆排序：
    1）排序开始，首先输出堆顶元素，因为它是最大值；
    2）将堆顶元素和最后一个元素交换；
    3）将前面n-1个节点继续进行堆调整的过程，再将根节点取出，交换堆顶和最后一个元素；
    4）这样一直到所有节点都取出，则排序完成。
 */

// 堆排序
function heapSort(&$arr) {
    $len = count($arr);
    // 先将数组构造成大根堆 复杂度为 O(n)
    for ($i = floor($len / 2) - 1; $i >= 0; $i--) {
        //从第一个非叶子结点从下至上，从右至左调整结构
        adjustHeap($arr, $i, $len);
    }
    // 调整堆结构+交换堆顶元素与末尾元素 复杂度为 O(n * log n);
    for ($j = $len - 1; $j > 0; $j--) {
        swap($arr, 0, $j);  // 将堆顶元素与末尾元素进行交换
        adjustHeap($arr, 0, $j); // 重新对堆进行调整 因为已经满足最大顶堆，所以只要对另一半重新调整即可 为 log * n 的复杂度
    }
}

// 调整堆
function adjustHeap(&$arr, $i, $length) {
    for ($k = 2 * $i + 1; $k < $length; $k = 2 * $k + 1) {// 左孩子2 * 𝑖+1，右孩子2∗i + 2

        //如果有右孩子，并且右孩子大于左孩子，则用右孩子和父节点比较
        if ($k + 1 < $length && $arr[$k] < $arr[$k + 1]) {// 如果左子结点小于右子结点，k指向右子结点
            $k ++;
        }
        if ($arr[$i] < $arr[$k]) {
            swap($arr, $i, $k);
            $i = $k; // 继续往下
        } else {
            break;  // 已经满足大根堆
        }

    }
}

// 交换2个值
function swap(&$arr, $a, $b) {
    $temp = $arr[$a];
    $arr[$a] = $arr[$b];
    $arr[$b] = $temp;
}

// 测试
$arr = array(50,45,40,20,25,35,30,10,15);
heapSort($arr);
print_r($arr);

